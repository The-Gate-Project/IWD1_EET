// *** Functions for internal use ***

// To determine game types more easily
OUTER_SET GAME_IS_BGEE = (GAME_IS ~bgee~ AND NOT GAME_INCLUDES ~sod~) ? 1 : 0
OUTER_SET GAME_IS_SOD = (GAME_IS ~bgee~ AND GAME_INCLUDES ~sod~) ? 1 : 0
OUTER_SET GAME_IS_BG2EE = (GAME_IS ~bg2ee~) ? 1 : 0
OUTER_SET GAME_IS_IWDEE = (GAME_IS ~iwdee~) ? 1 : 0
OUTER_SET GAME_IS_EET = (GAME_IS ~eet~) ? 1 : 0
OUTER_SET GAME_IS_EET_IWD = (GAME_IS ~eet~ AND FILE_EXISTS_IN_GAME ~id1000.are~) ? 1 : 0
OUTER_SET SPELL_REV = (MOD_IS_INSTALLED ~setup-spell_rev.tp2~ 0) ? 1 : 0


/** TO_HEX_NUMBER
 * Converts any decimal number into a hexadecimal number
 */
DEFINE_ACTION_FUNCTION TO_HEX_NUMBER
INT_VAR
  value     = 0   // the decimal number
  minDigits = 1   // min. number of digits in return value (not counting sign)
  prefix    = 0   // whether to return number with "0x" prefix
RET
  hexNumber       // returned as string without prefix
BEGIN
  ACTION_IF (minDigits < 1) BEGIN OUTER_SET minDigits = 1 END
  ACTION_IF (minDigits > 8) BEGIN OUTER_SET minDigits = 8 END
  OUTER_TEXT_SPRINT hexNumber ~~
  ACTION_DEFINE_ARRAY digit BEGIN ~0~ ~1~ ~2~ ~3~ ~4~ ~5~ ~6~ ~7~ ~8~ ~9~ ~a~ ~b~ ~c~ ~d~ ~e~ ~f~ END

  ACTION_IF (value < 0) BEGIN
    OUTER_SET signed = 1
    OUTER_SET value = 0 - value
  END ELSE BEGIN
    OUTER_SET signed = 0
  END

  OUTER_WHILE (value != 0) BEGIN
    OUTER_SET curDigit = value BAND 0xf
    OUTER_SET value = value BLSR 4
    OUTER_TEXT_SPRINT hexDigit $EVAL digit(~%curDigit%~)
    OUTER_TEXT_SPRINT hexNumber ~%hexDigit%%hexNumber%~
  END

  OUTER_WHILE (STRING_LENGTH ~%hexNumber%~ < minDigits) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~0%hexNumber%~
  END

  ACTION_IF (prefix) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~0x%hexNumber%~
  END

  ACTION_IF (signed) BEGIN
    OUTER_TEXT_SPRINT hexNumber ~-%hexNumber%~
  END
END

DEFINE_PATCH_FUNCTION TO_HEX_NUMBER
INT_VAR
  value     = 0
  minDigits = 1
  prefix    = 0
RET
  hexNumber
BEGIN
  INNER_ACTION BEGIN
    LAF TO_HEX_NUMBER INT_VAR value = value minDigits = minDigits prefix = prefix RET hexNumber END
  END
END


/** TO_DEC_NUMBER
 * Converts a hexadecimal value back into a decimal number.
 * STR_VAR hexNumber  A string containing a hexadecimal number without prefix.
 * RET value          The resulting decimal number as int value. Returns -1 on error.
 */
DEFINE_ACTION_FUNCTION TO_DEC_NUMBER
STR_VAR
  hexNumber  = ~~
RET
  value
BEGIN
  OUTER_SET value = "-1"

  ACTION_IF (~%hexNumber%~ STRING_EQUAL ~~) BEGIN
    OUTER_SET value = 0
  END ELSE BEGIN
    // checking for sign
    ACTION_IF (~%hexNumber%~ STRING_MATCHES_REGEXP ~-.+~ = 0) BEGIN
      OUTER_SET signed = 1
      OUTER_PATCH_SAVE hexNumber ~%hexNumber%~ BEGIN REPLACE_TEXTUALLY ~^-~ ~~ END
    END ELSE BEGIN
      OUTER_SET signed = 0
    END

    // checking for prefix
    ACTION_IF (~%hexNumber%~ STRING_MATCHES_REGEXP ~^0[xX].+~ = 0) BEGIN
      OUTER_PATCH_SAVE hexNumber ~%hexNumber%~ BEGIN REPLACE_TEXTUALLY ~^0[xX]~ ~~ END
    END

    // converting number
    OUTER_SET curValue = 0
    OUTER_SET scale = 1
    OUTER_SET strlen = STRING_LENGTH ~%hexNumber%~
    OUTER_FOR (idx = strlen - 1; idx >= 0; --idx ) BEGIN
      OUTER_PATCH ~%hexNumber%~ BEGIN READ_BYTE idx hexDigit END
      OUTER_SET hexDigit = hexDigit BAND 0xff
      ACTION_IF (hexDigit >= 48 AND hexDigit <= 57) BEGIN // 0..9
        OUTER_SET digit = hexDigit - 48
      END ELSE ACTION_IF (hexDigit >= 65 AND hexDigit <= 70) BEGIN  // A..F
        OUTER_SET digit = hexDigit - 55
      END ELSE ACTION_IF (hexDigit >= 97 AND hexDigit <= 102) BEGIN // a..f
        OUTER_SET digit = hexDigit - 87
      END ELSE BEGIN
        OUTER_SET digit = 0
      END
      OUTER_SET curValue += digit*scale
      OUTER_SET scale = scale BLSL 4
    END

    ACTION_IF (signed) BEGIN
      OUTER_SET curValue = 0 - curValue
    END

    OUTER_SET value = curValue
  END
END

DEFINE_PATCH_FUNCTION TO_DEC_NUMBER
STR_VAR
  hexNumber  = ~~
RET
  value
BEGIN
  INNER_ACTION BEGIN
    LAF TO_DEC_NUMBER STR_VAR hexNumber = EVAL ~%hexNumber%~ RET value END
  END
END


/** IS_PATCHED_V2
 * Returns a non-zero value in "patched" if the game has been patched to v2.0 or higher.
 */
DEFINE_ACTION_FUNCTION IS_PATCHED_V2
RET patched
BEGIN
  OUTER_SET patched = (FILE_EXISTS ~engine.lua~ AND FILE_EXISTS_IN_GAME ~wmpflag.ids~) ? 1 : 0
END

DEFINE_PATCH_FUNCTION IS_PATCHED_V2
RET patched
BEGIN
  INNER_ACTION BEGIN LAF IS_PATCHED_V2 RET patched END END
END


/** ADD_IDS_ENTRY
 * Adds a new entry to a specified IDS file and returns its IDS value.
 * 
 * INT_VAR minValue       Minimum IDS value to consider. (Default: 0)
 * INT_VAR maxValue       Maximum IDS value to consider. (Default: 255)
 * INT_VAR preferredValue Try this IDS value first if available. (Default: unset)
 * INT_VAR hexadecimal    Set to nonzero to add IDS value in hexadecimal notation. (Default: 0)
 * STR_VAR idsFile        The IDS file to add the entry to.
 * STR_VAR identifier     The identifier name for the IDS value. Must not contain whitespace.
 * RET value              The IDS value if entry has been added successfully. -1 if entry could not be added.
 */
DEFINE_ACTION_FUNCTION ADD_IDS_ENTRY
INT_VAR
  minValue        = 0
  maxValue        = 255
  preferredValue  = "-1"
  hexadecimal     = 0
STR_VAR
  idsFile         = ""
  identifier      = ""
RET
  value
BEGIN
  OUTER_SET value = "-1"

  ACTION_IF (minValue < 0) BEGIN OUTER_SET minValue = 0 END
  ACTION_IF (maxValue < minValue) BEGIN OUTER_SET maxValue = minValue END

  ACTION_IF (~%idsFile%~ STRING_MATCHES_REGEXP ~.+\..+~ = 0) BEGIN
    OUTER_PATCH_SAVE idsFile ~%idsFile%~ BEGIN REPLACE_TEXTUALLY ~\(.+\)\.[^.]+~ ~\1~ END
  END

  ACTION_IF (FILE_EXISTS_IN_GAME ~%idsFile%.ids~) BEGIN
    // Try preferred value first
    OUTER_PATCH ~~ BEGIN
      PATCH_IF (preferredValue >= minValue AND preferredValue <= maxValue) BEGIN
        LOOKUP_IDS_SYMBOL_OF_INT retVal ~%idsFile%~ preferredValue
        PATCH_IF (~%retVal%~ STRING_EQUAL ~%preferredValue%~) BEGIN
          SET value = preferredValue
        END
      END
    END
    
    // Looking for available IDS slot
    ACTION_IF (value = "-1") BEGIN
      OUTER_PATCH ~~ BEGIN
        FOR (v = minValue; v <= maxValue; v += 1) BEGIN
          LOOKUP_IDS_SYMBOL_OF_INT retVal ~%idsFile%~ v
          PATCH_IF (~%retVal%~ STRING_EQUAL ~%v%~) BEGIN
            SET value = v
            SET v = maxValue + 1
          END
        END
      END
    END

    // Falling back to preferred value if no free slot found
    ACTION_IF (value = "-1" AND preferredValue >= minValue AND preferredValue <= maxValue) BEGIN
      OUTER_SET value = preferredValue
    END

    // Adding new entry
    ACTION_IF (value != "-1") BEGIN
      ACTION_IF (hexadecimal) BEGIN
        LAF TO_HEX_NUMBER INT_VAR value = value RET hexNumber END
        OUTER_TEXT_SPRINT idsValue ~0x%hexNumber%~
      END ELSE BEGIN
        OUTER_TEXT_SPRINT idsValue ~%value%~
      END

      APPEND ~%idsFile%.ids~ ~%idsValue% %identifier%~ UNLESS ~%identifier%~
      OUTER_SET value = IDS_OF_SYMBOL (~%idsFile%~ ~%identifier%~)
      ACTION_IF (value < minValue OR value > maxValue) BEGIN
        OUTER_SET value = "-1"
      END
    END
  END
END

/* ADD_SPLPROT_ENTRY */
DEFINE_ACTION_FUNCTION ADD_SPLPROT_ENTRY
	INT_VAR
		stat_hex    = 1
		value_hex   = 0
		add_number  = 1
	STR_VAR
		label       = ~~
		definition  = ~~
	RET
		index
		exists
		label1
BEGIN
	OUTER_SET index  = "-1"
	OUTER_SET exists =   0
	ACTION_IF (NOT ~%definition%~ STR_EQ ~~) BEGIN
		//extract definition
		OUTER_SPRINT ~stat~ ~~
		OUTER_SPRINT ~value~ ~~
		OUTER_SPRINT ~rel~ ~~
		OUTER_INNER_PATCH_SAVE definition ~%definition%~ BEGIN
			REPLACE_TEXTUALLY ~[ %TAB%]~ ~*~
			SET lng  = BUFFER_LENGTH
			SET true = 1
			SET cmp  = 0
			FOR ( i = 0 ; i < lng ; ++i ) BEGIN
				READ_ASCII i z (1)
				PATCH_IF ( ~%z%~ STR_CMP ~*~ ) BEGIN
					PATCH_IF ( true = 1 ) BEGIN
						PATCH_MATCH cmp WITH
							0 BEGIN SPRINT ~stat~  ~%stat%%z%~ END
							1 BEGIN SPRINT ~value~ ~%value%%z%~ END
							2 BEGIN SPRINT ~rel~   ~%rel%%z%~ END
						DEFAULT
						END
					END ELSE BEGIN
						SET true = 1
						SET cmp = cmp + 1
						PATCH_MATCH cmp WITH
							0 BEGIN SPRINT ~stat~  ~%stat%%z%~ END
							1 BEGIN SPRINT ~value~ ~%value%%z%~ END
							2 BEGIN SPRINT ~rel~   ~%rel%%z%~ END
						DEFAULT
						END
					END
				END ELSE BEGIN
					SET true = 0
				END
			END
		END
		OUTER_SET stat  =  ~%stat%~
		OUTER_SET value = ~%value%~
		OUTER_SET rel   =   ~%rel%~
		COPY_EXISTING ~splprot.2da~ ~override~
			COUNT_2DA_ROWS 4 table
			//find existing entry
			FOR ( i = 0 ; i < table ; ++i ) BEGIN
				SET true = 0
				READ_2DA_ENTRY i 0 4 label1
				READ_2DA_ENTRY i 1 4 stat1
				PATCH_IF ( IS_AN_INT ~stat1~ )  AND ( stat = stat1 )   BEGIN SET true = true + 1 END
				READ_2DA_ENTRY i 2 4 value1
				PATCH_IF ( IS_AN_INT ~value1~ ) AND ( value = value1 ) BEGIN SET true = true + 1 END
				READ_2DA_ENTRY i 3 4 rel1
				PATCH_IF ( IS_AN_INT ~rel1~ )   AND ( rel = rel1 )     BEGIN SET true = true + 1 END
				PATCH_IF ( true = 3 ) BEGIN
					SET index = i
					SET exists = 1
					SET i = table
					TEXT_SPRINT ~label1~ ~%label1%	%stat1%	%value1%	%rel1%~
				END
			END
			//add_new_string to empty
			PATCH_IF ( index < 0 ) BEGIN
				SET trueex = 0
				FOR ( i = 0 ; i < table ; ++i ) BEGIN
					SET true = 0
					PATCH_IF NOT trueex BEGIN
						READ_2DA_ENTRY i 1 4 stat1
						PATCH_IF ( ~%stat1%~  STR_EQ ~*~ ) BEGIN SET true = true + 1 END
						READ_2DA_ENTRY i 1 4 value1
						PATCH_IF ( ~%value1%~ STR_EQ ~*~ ) BEGIN SET true = true + 1 END
						READ_2DA_ENTRY i 1 4 rel1
						PATCH_IF ( ~%rel1%~   STR_EQ ~*~ ) BEGIN SET true = true + 1 END
						PATCH_IF ( true = 3 ) BEGIN
							SET index = i
							SET i = table
							PATCH_IF add_number BEGIN SPRINT nbr ~%index%_~ END ELSE BEGIN SPRINT nbr ~~ END
							TEXT_SPRINT ~label1~ ~%nbr%%label%	%stat%	%value%	%rel%~
							SET_2DA_ENTRY index 0 4 ~%nbr%%label%~
							SET_2DA_ENTRY index 1 4 ~%stat%~
							SET_2DA_ENTRY index 2 4 ~%value%~
							SET_2DA_ENTRY index 3 4 ~%rel%~
						END
					END
				END
			END
			//add_new_string
			PATCH_IF ( index < 0 ) BEGIN
				SET index = table
				PATCH_IF (~%label%~ STR_EQ ~~) BEGIN TEXT_SPRINT label ~%index%~ END
				PATCH_IF ( stat >= 0 ) AND ( stat_hex = 1 ) BEGIN
					LPF TO_HEX_NUMBER INT_VAR value=stat minDigits=3 prefix=1 RET stat=hexNumber END
				END
				PATCH_IF ( value >= 0 ) AND ( value_hex = 1 ) BEGIN
					LPF TO_HEX_NUMBER INT_VAR value=value prefix=1 RET value=hexNumber END
				END
				PATCH_IF add_number BEGIN SPRINT nbr ~%index%_~ END ELSE BEGIN SPRINT nbr ~~ END
				TEXT_SPRINT ~label1~ ~%nbr%%label%	%stat%	%value%	%rel%~
				INSERT_2DA_ROW index 4 ~%label1%~
				PRETTY_PRINT_2DA
			END
			BUT_ONLY_IF_IT_CHANGES
			IF_EXISTS
	END
END

/* FC_ADD_CLAB_DATA */
DEFINE_ACTION_FUNCTION FC_ADD_CLAB_DATA
	INT_VAR
		level = 1
		top   = 1
	STR_VAR
		file  = ""
		label = ""
		abil  = ""
		type  = "AP_"
	RET
		done
BEGIN
	OUTER_SET done = 0
	OUTER_SET exists = 0
	ACTION_IF ( ~%file%~ STR_CMP ~~ ) AND
	          ( ~%abil%~ STR_CMP ~~ ) AND
	          ( level > 0 ) AND
	          ( STRING_LENGTH ~%abil%~ < 9 ) BEGIN
		ACTION_IF NOT FILE_EXISTS_IN_GAME ~%file%.2da~ BEGIN
			OUTER_SPRINT header ~	~
			OUTER_SPRINT ability ~ABILITY1~
			OUTER_FOR ( i = 1 ; i < 51 ; ++i ) BEGIN
				OUTER_SPRINT header ~%header%	%i%~
				OUTER_SPRINT ability ~%ability%	****~
			END
<<<<<<<< .../clabfile.2da
2DA V1.0
****
%header%
%ability%
>>>>>>>>
			COPY ~.../clabfile.2da~ ~override/%file%.2da~ EVALUATE_BUFFER PRETTY_PRINT_2DA
		END
		COPY_EXISTING ~%file%.2da~ ~override~
			COUNT_2DA_COLS cols
			SET rows = 0
			PATCH_IF ( level < cols ) BEGIN exists = 1 END
			PATCH_IF exists BEGIN
				COUNT_2DA_ROWS cols rows
				SET line = 0
				PATCH_IF ( rows > 0 ) BEGIN
					FOR ( i = 0 ; i < rows ; ++i ) BEGIN
						READ_2DA_ENTRY i 0 cols lbl
						READ_2DA_ENTRY i level cols value
						PATCH_IF NOT done BEGIN
							PATCH_IF ( ~%label%~ STR_EQ ~~ ) BEGIN
								PATCH_IF ( ~%value%~ STR_EQ ~****~ ) BEGIN
									SET_2DA_ENTRY i level cols ~%type%%abil%~
									SET done = 1
									SET i = rows
								END
							END ELSE BEGIN
								PATCH_IF ( ~%label%~ STR_EQ ~%lbl%~ ) BEGIN
									PATCH_IF ( ~%value%~ STR_EQ ~****~ ) BEGIN
										SET_2DA_ENTRY i level cols ~%type%%abil%~
										SET done = 1
										SET i = rows
									END
								END
							END
						END
					END
				END
				SET rows = rows + 1
				PATCH_IF ( ~%label%~ STR_EQ ~~ ) BEGIN SPRINT label ~ABILITY%rows%~ END
				FOR ( i = 1 ; i < cols ; ++i ) BEGIN
					PATCH_IF ( i = level ) BEGIN SPRINT value ~%type%%abil%~
					END ELSE BEGIN SPRINT value ~****~ END
					SPRINT label ~%label%	%value%~
				END
				PATCH_IF top BEGIN SET pos = 0 END ELSE BEGIN SET pos = rows END
				INSERT_2DA_ROW 0 cols ~%label%~
				SET done = 1
			END
			BUT_ONLY_IF_IT_CHANGES
	END
END

/** APPEND_STATDESC_ENTRY
*/
DEFINE_ACTION_FUNCTION APPEND_STATDESC_ENTRY
INT_VAR
  strref   = "-1"
STR_VAR
  bam_file = "*"
RET
  index
BEGIN
  OUTER_SET index = "-1"
  OUTER_SET minus = "-1"
  
  ACTION_IF ( strref >= 0 ) BEGIN
    ACTION_IF ( bam_file STRING_EQUAL ~~ ) OR
              ( bam_file STRING_EQUAL ~*~ ) BEGIN
      OUTER_TEXT_SPRINT bam_file ~****~
    END
    
    ACTION_IF (FILE_EXISTS_IN_GAME ~statdesc.2da~) BEGIN
      COPY_EXISTING ~statdesc.2da~ ~override~
        //READ_2DA_ENTRIES_NOW table 3
        COUNT_2DA_ROWS 3 table
        FOR ( idx = 0 ; idx < table ; ++idx ) BEGIN
          READ_2DA_ENTRY idx 0 3 number
          READ_2DA_ENTRY idx 1 3 curStrref
          PATCH_IF ( idx < number ) BEGIN
            TEXT_SPRINT line ~%idx%         %strref%         %bam_file%~
            INSERT_2DA_ROW idx 3 ~%line%~
            SET index = idx
            SET idx = idx + 100
          END
          PATCH_IF ( ~%curStrref%~ = ~%minus%~ ) BEGIN
            SET_2DA_ENTRY idx 1 3 ~%strref%~
            SET_2DA_ENTRY idx 2 3 ~%bam_file%~
            //SET_2DA_ENTRIES_NOW table 3
            SET index = number
            SET idx = idx + 100
          END
        END
        
        PATCH_IF ( index < 0 ) BEGIN
          TEXT_SPRINT line ~%table%         %strref%         %bam_file%~
          INSERT_2DA_ROW table 3 ~%line%~
          SET index = table
        END
        
        PRETTY_PRINT_2DA
      BUT_ONLY
    END
    
  END
END

/** COPY_SPL_ABILITY
  ability 0x28
  effect  0x30
*/
DEFINE_PATCH_FUNCTION COPY_SPL_ABILITY
INT_VAR
  inc_timing       = 1
  timing_increment = 6
  num_copies       = 1
  inc_lvl          = 1
  increment_lvl    = 1
STR_VAR
  
BEGIN
  PATCH_IF ( num_copies < 1)       BEGIN SET num_copies = 1       END
  PATCH_IF ( timing_increment < 1) BEGIN SET timing_increment = 6 END
  PATCH_IF ( increment_lvl < 1)    BEGIN SET increment_lvl = 1    END
  
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_cnt
  READ_LONG  0x6a seff_off
  READ_SHORT 0x70 seff_cnt
  SET eff_off = seff_off + seff_cnt * 0x30
  
  PATCH_IF ( abil_cnt = 1 ) BEGIN
    READ_SHORT abil_off + 0x1e eff_cnt
    READ_SHORT abil_off + 0x20 eff_first
    READ_SHORT abil_off + 0x10 level
    
    SET len = eff_cnt * 0x30
    READ_ASCII eff_off data (%len%)
    //COPY EFFECTS
    FOR ( i = 0 ; i < num_copies ; ++i ) BEGIN
      SET eff_off = eff_off + len
      INSERT_BYTES eff_off len
      WRITE_EVALUATED_ASCII  eff_off ~%data%~ (%len%)
    END
    
    SET len = 0x28
    READ_ASCII abil_off data (%len%)
    //COPY ABILITY
    FOR ( i = 0 ; i < num_copies ; ++i ) BEGIN
      SET abil_off = abil_off + len
      INSERT_BYTES abil_off len
      WRITE_EVALUATED_ASCII  abil_off ~%data%~ (%len%)
      PATCH_IF ( inc_lvl = 1 ) BEGIN
        SET level = level + increment_lvl
        WRITE_SHORT abil_off + 0x10 level
      END
      SET abil_cnt = abil_cnt + 1
      SET eff_first = eff_first + eff_cnt
      WRITE_SHORT abil_off + 0x20 eff_first
      SET seff_off = seff_off + len
    END
    WRITE_SHORT 0x68 abil_cnt
    WRITE_LONG  0x6a seff_off
    
    //INCREMENT TIMING
    PATCH_IF ( inc_timing = 1 ) BEGIN
      READ_LONG  0x64 abil_off
      READ_SHORT 0x68 abil_cnt
      FOR ( i = 0 ; i < abil_cnt ; ++i ) BEGIN
        PATCH_IF ( i > 0 ) BEGIN
          SET offset = abil_off + 0x28 * i
          READ_SHORT offset + 0x1e eff_cnt
          READ_SHORT offset + 0x20 first
          FOR ( j = 0 ; j < eff_cnt ; ++j ) BEGIN
            SET eoffset = seff_off + first * 0x30 + j * 0x30
            READ_BYTE  eoffset + 0x0c time
            PATCH_IF ( time != 1 ) AND ( time != 9 ) /*OR ( time = 4 )*/ BEGIN
              READ_LONG  eoffset + 0x0e duration
              PATCH_IF ( duration >= 6 ) BEGIN
                SET duration = duration + timing_increment * i
                WRITE_LONG  eoffset + 0x0e duration
              END
            END
          END
        END
      END
    END
    
  END
  
END

DEFINE_PATCH_MACRO CONVERT_SPL_TO_INNATE BEGIN
  WRITE_SHORT 0x1c 4
  WRITE_LONG  0x1e 0
  WRITE_LONG  0x34 1
  READ_LONG   0x64 abil_off
  READ_SHORT  0x68 abil_num
  PATCH_IF ( abil_num > 0 ) BEGIN //0x28
    FOR ( i = 0 ; i < abil_num ; ++i ) BEGIN
      WRITE_SHORT abil_off + i * 0x28 + 0x2 4
    END
  END
END


// Animation slots reserved by vanilla or mod-added game creatures (in hexadecimal format)
// Supported mods:
// - Bearwalker + extended Werebear animation
// - Pack Mule
<<<<<<<< .../inlined/creature/animation/slots.txt
"0410" "1000" "1003" "1004" "1100" "1101" "1102" "1103" "1104" "1105" "1200" "1201" "1202" "1203" "1204" "1205" "1206" "1207" "1208" "1300" "2000" "2100" "2200" "2300" "3000" "3001" "4000" "4001" "4002" "4010" "4012" "4100" "4101" "4102" "4110" "4112" "4200" "4300" "4400" "4410" "4500" "4600" "4700" "4710" "4800" "5000" "5001" "5002" "5003" "5010" "5011" "5012" "5013" "5100" "5101" "5102" "5103" "5110" "5111" "5112" "5113" "5200" "5201" "5202" "5210" "5211" "5212" "5300" "5301" "5302" "5303" "5310" "5311" "5312" "5313" "6000" "6001" "6002" "6003" "6004" "6005" "6010" "6011" "6012" "6013" "6014" "6015" "6100" "6101" "6102" "6103" "6104" "6105" "6110" "6111" "6112" "6113" "6114" "6115" "6200" "6201" "6202" "6204" "6205" "6210" "6211" "6212" "6214" "6215" "6300" "6301" "6302" "6303" "6304" "6305" "6310" "6311" "6312" "6313" "6314" "6315" "6400" "6401" "6402" "6403" "6404" "6405" "6406" "6500" "6510" "6621" "7000" "7001" "7100" "7101" "7200" "7201" "7202" "7203" "7300" "7301" "7302" "7310" "7311" "7312" "7313" "7314" "7320" "7321" "7400" "7401" "7402" "7500" "7501" "7600" "7601" "7602" "7603" "7604" "7700" "7701" "7702" "7703" "7800" "7801" "7802" "7900" "7901" "7902" "7903" "7904" "7a00" "7a01" "7a02" "7a03" "7a04" "7b00" "7b01" "7b02" "7b03" "7b04" "7b05" "7b06" "7c00" "7c01" "7d00" "7d01" "7d02" "7d03" "7d04" "7d05" "7d06" "7d07" "7d08" "7e00" "7e01" "7f00" "7f01" "7f02" "7f03" "7f04" "7f05" "7f06" "7f07" "7f08" "7f09" "7f0a" "7f0b" "7f0c" "7f0d" "7f0e" "7f0f" "7f10" "7f11" "7f12" "7f13" "7f14" "7f15" "7f16" "7f17" "7f18" "7f19" "7f20" "7f21" "7f22" "7f23" "7f24" "7f27" "7f28" "7f29" "7f2a" "7f2b" "7f2c" "7f2d" "7f2e" "7f2f" "7f30" "7f31" "7f32" "7f33" "7f34" "7f35" "7f36" "7f37" "7f38" "7f39" "7f3a" "7f3b" "7f3c" "7f3d" "7f3e" "7f3f" "7f40" "7f41" "7f42" "7f43" "7f44" "7f45" "7f46" "7f47" "7f48" "7f49" "7f4a" "7f4b" "7f4c" "7f4d" "7f4e" "7f4f" "7f50" "7f51" "7f52" "7f53" "7f54" "7f55" "7f56" "7f57" "7f58" "7f59" "7f5a" "7f5b" "7f5c" "7f5d" "7f5e" "7f5f" "7f60" "7f61" "7f62" "8000" "8100" "8200" "9000" "a000" "a100" "a200" "a201" "a202" "b000" "b100" "b200" "b210" "b300" "b310" "b400" "b410" "b500" "b510" "b600" "b610" "b700" "c000" "c100" "c200" "c300" "c400" "c500" "c600" "c610" "c700" "c710" "c800" "c810" "c900" "c910" "ca00" "ca10" "cb00" "cc00" "cc01" "cc02" "cc04" "d000" "d100" "d200" "d300" "d400" "e000" "e010" "e020" "e040" "e050" "e060" "e070" "e080" "e090" "e0a0" "e0b0" "e0c0" "e0d0" "e0e0" "e0f0" "e0f1" "e0f2" "e200" "e210" "e220" "e230" "e240" "e241" "e242" "e243" "e244" "e245" "e246" "e247" "e248" "e249" "e24a" "e24b" "e24c" "e24d" "e24e" "e24f" "e250" "e251" "e252" "e253" "e254" "e255" "e256" "e257" "e258" "e259" "e25a" "e25b" "e25c" "e25d" "e25e" "e25f" "e260" "e261" "e262" "e263" "e264" "e265" "e266" "e267" "e26a" "e26b" "e26d" "e26e" "e26f" "e270" "e271" "e272" "e273" "e274" "e276" "e279" "e27d" "e27e" "e27f" "e280" "e281" "e282" "e283" "e288" "e289" "e28a" "e28b" "e28c" "e28d" "e28e" "e28f" "e290" "e291" "e292" "e293" "e294" "e300" "e310" "e320" "e330" "e400" "e410" "e420" "e430" "e440" "e441" "e442" "e443" "e444" "e500" "e510" "e520" "e600" "e610" "e6fe" "e700" "e710" "e720" "e800" "e810" "e820" "e830" "e840" "e900" "e910" "ea00" "ea10" "ea20" "eb00" "eb10" "eb20" "ec00" "ec10" "ec20" "ed00" "ed10" "ed20" "ee00" "ee10" "ef10"
>>>>>>>>
OUTER_TEXT_SPRINT animationSlotsPath ".../inlined/creature/animation/slots.txt"

/** FIND_FREE_ANIM_SLOT
 * Returns the first free creature animation slot in the range defined by slotMin and slotMax.
 * INT_VAR slotMin    Lowest available creature animation slot for the animation.
 * INT_VAR slotMax    Highest available creature animation slot for the animation.
 * INT_VAR slotSteps  How many slots to skip after each iteration, starting from slotMin.
 *                    Setting this parameter is useful if compatible animation slots are always 
 *                    a fixed distance apart (e.g. at a distance of 0x10 each)
 * RET slot           A free animation slot. Returns -1 if none found.
 */
DEFINE_ACTION_FUNCTION FIND_FREE_ANIM_SLOT
INT_VAR
  slotMin   = 0
  slotMax   = (slotMin BAND 0xf000) + 0x1000
  slotSteps = 1
RET
  slot
BEGIN
  OUTER_SET slot = "-1"
  ACTION_IF (slotSteps < 1) BEGIN OUTER_SET slotSteps = 1 END
  ACTION_IF (slotMin < 0) BEGIN OUTER_SET slotMin = 0 END
  ACTION_IF (slotMax < 0) BEGIN OUTER_SET slotMax = 0 END
  ACTION_IF (slotMax < slotMin) BEGIN
    OUTER_SET tmp = slotMin
    OUTER_SET slotMin = slotMax
    OUTER_SET slotMax = tmp
  END

  // animslots.txt contains reserved creature animation slots
  COPY - ~%animationSlotsPath%~ ~%animationSlotsPath%~
    READ_ASCII 0 slotList (SOURCE_SIZE)
    FOR (idx = slotMin; idx < slotMax; idx += slotSteps) BEGIN
      LOOKUP_IDS_SYMBOL_OF_INT name ~animate~ idx
      PATCH_IF (~%name%~ STRING_EQUAL ~%idx%~) BEGIN
        LPF TO_HEX_NUMBER INT_VAR value = idx minDigits = 4 RET hexNumber END
        PATCH_IF (NOT FILE_EXISTS_IN_GAME ~%hexNumber%.ini~ AND 
                  ~%slotList%~ STRING_CONTAINS_REGEXP ~"%hexNumber%"~ != 0) BEGIN
          SET slot = idx
          SET idx = slotMax
        END
      END
    END
END

DEFINE_PATCH_FUNCTION FIND_FREE_ANIM_SLOT
INT_VAR
  slotMin   = 0
  slotMax   = (slotMin BAND 0xf000) + 0x1000
  slotSteps = 1
RET
  slot
BEGIN
  INNER_ACTION BEGIN
    LAF FIND_FREE_ANIM_SLOT INT_VAR slotMin = slotMin slotMax = slotMax slotSteps = slotSteps RET slot END
  END
END


// Work-around for a buggy WeiDU function
DEFINE_PATCH_FUNCTION ADD_SPELL_EFFECT
  INT_VAR opcode = 0
          target = 0
          timing = 0
          parameter1 = 0
          parameter2 = 0
          power = 0
          resist_dispel = 0
          duration = 0
          probability1 = 100
          probability2 = 0
          dicenumber = 0
          dicesize = 0
          savingthrow = 0
          savebonus = 0
          header = 0
          insert_point = "-1"
          special = 0
          ___#special = special   // fixed spelling error
  STR_VAR resource = ~~
BEGIN
  LAUNCH_PATCH_MACRO ~ADD_SPELL_EFFECT~
END


/** CREATE_WILD_SURGE_SPELL
 * Creates a spell which contains all externalized wild surge effects.
 * STR_VAR resName    Name of the resulting spell (without extension).
 * STR_VAR resDefault Name of the default spell when no externalized resource is available or spell is cast successfully.
 */
DEFINE_ACTION_FUNCTION CREATE_WILD_SURGE_SPELL
STR_VAR
  resName = ~~
  resDefault = ~~
BEGIN
  ACTION_IF (NOT ~%resName%~ STRING_EQUAL ~~) BEGIN
    // retrieving wild surge resources and strrefs
    COPY_EXISTING - ~wildmag.2da~ ~override~
      COUNT_2DA_COLS numCols
      COUNT_2DA_ROWS numCols numRows
      PATCH_IF (numRows > 100) BEGIN numRows = 100 END
      FOR (idx = 0; idx < numRows; ++idx) BEGIN
        READ_2DA_ENTRY idx 1 numCols res
        PATCH_IF (NOT ~%res%~ STRING_EQUAL ~*~ AND FILE_EXISTS_IN_GAME ~%res%.spl~) BEGIN
          TEXT_SPRINT $EVAL resRef(~%idx%~) ~%res%~
        END ELSE BEGIN
          TEXT_SPRINT $EVAL resRef(~%idx%~) ~%resDefault%~
        END

        READ_2DA_ENTRY idx 2 numCols str
        PATCH_IF (IS_AN_INT ~%str%~) BEGIN
          SET $EVAL strref(~%idx%~) = str
        END ELSE BEGIN
          SET $EVAL strref(~%idx%~) = "-1"
        END
      END

    // applying wild surge effects to target spell
    CREATE SPL ~%resName%~
      WRITE_SHORT 0x1c 4      // Spell type = innate
      WRITE_LONG 0x34 1       // Spell level
      WRITE_LONG 0x64 0x72    // abilities offset
      WRITE_SHORT 0x68 1      // # abilities
      WRITE_LONG 0x6a 0x9a    // effects offset
      INSERT_BYTES 0x72 0x28  // space for ability
      // creating ability structure
      WRITE_SHORT 0x72 1      // type = melee
      WRITE_SHORT 0x74 4      // location = innate
      WRITE_BYTE 0x7e 1       // target = living creature
      WRITE_SHORT 0x80 1      // range
      WRITE_SHORT 0x82 1      // min. level
      WRITE_SHORT 0x8e 1      // damage type
      WRITE_SHORT 0x94 1      // # charges
      WRITE_SHORT 0x98 1      // projectile = none

      FOR (idx = 0; idx < numRows; ++idx) BEGIN
        TEXT_SPRINT res $EVAL resRef(~%idx%~)
        SET str = $EVAL strref(~%idx%~)
        LPF ADD_SPELL_EFFECT
        INT_VAR
          opcode = 146      // Cast spell
          target = 2        // Preset target
          parameter2 = 1    // Cast instantly (ignore level)
          timing = 1        // Instant/Permanent until death
          probability1 = idx
          probability2 = idx
        STR_VAR
          resource = EVAL "%res%"
        END

        LPF ADD_SPELL_EFFECT
        INT_VAR
          opcode = 139      // Display string
          target = 2        // Preset target
          parameter1 = str
          timing = 1        // Instant/Permanent until death
          probability1 = idx
          probability2 = idx
        END
      END
  END
END


/** DEFINE_RANDOM_TREASURE
 * Adds a new random treasure entry to RNDTRES.2DA. The entry is generated with a specified percentage for the given item.
 * This function also creates a treasure placeholder item if needed.
 * INT_VAR chance   The chance of the item to be generated (in percent).
 * STR_VAR treasure The resource name of the placeholder treasure item without extension
 * STR_VAR defItem  Default item for the columns not defined by chance.
 * STR_VAR item     The resource name of the item to generate by the random treasure item.
 * RET success      Returns non-zero on success and zero on fail.
 */
DEFINE_ACTION_FUNCTION DEFINE_RANDOM_TREASURE
INT_VAR
  chance    = 100
STR_VAR
  treasure  = ~~
  defItem   = ~A7!EMPTY~
  item      = ~~
RET
  success
BEGIN
  LAF DEFINE_RANDOM_TREASURE_EX INT_VAR chance_0 = chance STR_VAR treasure = EVAL ~%treasure%~ defItem = EVAL ~%defItem%~ item_0 = EVAL ~%item%~ RET success END
END


/** DEFINE_RANDOM_TREASURE_EX
 * Adds a new random treasure entry to RNDTRES.2DA. The entry is generated with the specified percentages of the given items.
 * This function also creates a treasure placeholder item if needed.
 * INT_VAR chance_x The chance of the associated item to be generated (in percent). x must be a sequential number, starting at 0.
 *                  Important: The sum of chances must not be greater than 100%.
 * STR_VAR treasure The resource name of the placeholder treasure item without extension
 * STR_VAR defItem  Default item for the columns not defined by chance_x.
 * STR_VAR item_x   The resource names of the items to generate by the random treasure item. x must be a sequential number, starting at 0.
 * RET success      Returns non-zero on success and zero on fail.
 */
DEFINE_ACTION_FUNCTION DEFINE_RANDOM_TREASURE_EX
INT_VAR
  // chance_0, chance_1, ...
STR_VAR
  treasure  = ~~
  defItem   = ~A7!EMPTY~
  // item_0, item_1, ...
RET
  success
BEGIN
  OUTER_SET success = 0
  ACTION_IF (FILE_EXISTS_IN_GAME ~rndtres.2da~ AND
             NOT ~%treasure%~ STRING_EQUAL ~~ AND
             STRING_LENGTH ~%treasure%~ <= 8) BEGIN
    // validating input
    OUTER_SET numItems = 0
    OUTER_SET failed = 0
    OUTER_SET sumChance = 0
    OUTER_FOR (idx = 0; idx < 100; ++idx) BEGIN
      ACTION_IF (VARIABLE_IS_SET $EVAL chance(~%idx%~) AND VARIABLE_IS_SET $EVAL item(~%idx%~)) BEGIN
        ACTION_IF (sumChance > 100) BEGIN OUTER_SET failed = 1 OUTER_SET idx = 100 END
        OUTER_SET valChance = $EVAL chance(~%idx%~)
        ACTION_IF (valChance < 0) BEGIN OUTER_SET $EVAL chance(~%idx%~) = 0 END
        ACTION_IF (valChance > 100) BEGIN OUTER_SET $EVAL chance(~%idx%~) = 100 END
        OUTER_SET sumChance += valChance

        OUTER_TEXT_SPRINT name $EVAL item(~%idx%~)
        ACTION_IF (~%name%~ STRING_EQUAL ~~ OR STRING_LENGTH ~%name%~ > 8) BEGIN OUTER_SET failed = 1 OUTER_SET idx = 100 END
      END ELSE BEGIN
        OUTER_SET numItems = idx
        OUTER_SET idx = 100
      END
    END
    ACTION_IF (numItems = 0) BEGIN OUTER_SET failed = 1 END

    ACTION_IF (failed = 0) BEGIN
      COPY_EXISTING ~rndtres.2da~ ~override~
        COUNT_2DA_COLS numCols
        COUNT_2DA_ROWS numCols numRows

        // check if entry already exists
        FOR (idx = 0; idx < numRows; ++idx) BEGIN
          READ_2DA_ENTRY idx 0 numCols name
          PATCH_IF (~%name%~ STRING_EQUAL_CASE ~%treasure%~) BEGIN
            SET failed = 1
            SET idx = numRows
          END
        END

        PATCH_IF (failed = 0) BEGIN
          // generating entry name
          TEXT_SPRINT newEntry ~%treasure%~
          FOR (idx = 9 - (STRING_LENGTH ~%treasure%~); idx > 0; --idx ) BEGIN TEXT_SPRINT newEntry ~%newEntry% ~ END

          SET numCols -= 1  // exclude treasure name column
          SET sumItems = 0
          FOR (idxItem = 0; idxItem < numItems; ++idxItem) BEGIN
            // calculating item count
            SET itmChance = $EVAL chance(~%idxItem%~)
            TEXT_SPRINT itmName $EVAL item(~%idxItem%~)
            SET itmCount = (itmChance * numCols) / 100
            PATCH_IF (itmChance > 0 AND itmCount = 0) BEGIN SET itmCount += 1 END
            PATCH_IF (itmChance < 100 AND itmCount = numCols) BEGIN SET itmCount -= 1 END
            SET sumItems += itmCount
            PATCH_IF (sumItems <= numCols) BEGIN
              // adding item to entry
              FOR (col = 0; col < itmCount; ++col) BEGIN
                TEXT_SPRINT newEntry ~%newEntry%%itmName%~
                FOR (idx = 9 - (STRING_LENGTH ~%itmName%~); idx > 0; --idx ) BEGIN TEXT_SPRINT newEntry ~%newEntry% ~ END
              END
            END ELSE BEGIN
              SET idxItem = numItems
            END
          END

          // adding empty items
          FOR (idx = 9 - (STRING_LENGTH ~%defItem%~); idx > 0; --idx ) BEGIN TEXT_SPRINT defItem ~%defItem% ~ END
          FOR (col = sumItems; col < numCols; ++col) BEGIN
            TEXT_SPRINT newEntry ~%newEntry%%defItem%~
          END

          // adding entry to 2DA
          INSERT_2DA_ROW numRows (numCols + 1) ~%newEntry%~
        END

      ACTION_IF (failed = 0) BEGIN
        ACTION_IF (NOT FILE_EXISTS ~%treasure%.itm~ AND FILE_EXISTS_IN_GAME ~rndtre01.itm~) BEGIN
          COPY_EXISTING ~rndtre01.itm~ ~override/%treasure%.itm~
        END
        OUTER_SET success = 1
      END
    END
  END
END


/** ARE_INDEX_OF_ACTOR
 * Attempts to determine the index of an ARE actor structure.
 * INT_VAR defaultIndex Returned if no actor matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching actor to be returned. (Default: 0)
 * STR_VAR name         Name of actor to find.
 * RET index            The actor index if found, or defaultIndex if not found.
 * RET offset           The offset of the actor structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_ACTOR
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  name = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  READ_LONG 0x54 ofsActors
  READ_SHORT 0x58 numActors
  FOR (idx = 0; idx < numActors; ++idx) BEGIN
    SET curOfs = ofsActors + (idx * 0x110)
    READ_ASCII curOfs curName ( 32 ) NULL
    PATCH_IF (~%curName%~ STRING_EQUAL_CASE ~%name%~) BEGIN
      PATCH_IF (skip <= 0) BEGIN
        SET index = idx
        SET offset = curOfs
        SET idx = numActors
      END ELSE BEGIN
        SET skip -= 1
      END
    END
  END
END

/** ARE_INDEX_OF_REGION
 * Attempts to determine the index of an ARE region structure.
 * INT_VAR defaultIndex Returned if no region matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching region to be returned. (Default: 0)
 * STR_VAR name         Name of region to find.
 * RET index            The region index if found, or defaultIndex if not found.
 * RET offset           The offset of the region structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_REGION
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  name = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  READ_SHORT 0x5a numRegions
  READ_LONG 0x5c ofsRegions
  FOR (idx = 0; idx < numRegions; ++idx) BEGIN
    SET curOfs = ofsRegions + (idx * 0xc4)
    READ_ASCII curOfs curName ( 32 ) NULL
    PATCH_IF (~%curName%~ STRING_EQUAL_CASE ~%name%~) BEGIN
      PATCH_IF (skip <= 0) BEGIN
        SET index = idx
        SET offset = curOfs
        SET idx = numRegions
      END ELSE BEGIN
        SET skip -= 1
      END
    END
  END
END

/** ARE_INDEX_OF_CONTAINER
 * Attempts to determine the index of an ARE container structure.
 * INT_VAR defaultIndex Returned if no container matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching container to be returned. (Default: 0)
 * STR_VAR name         Name of container to find.
 * RET index            The container index if found, or defaultIndex if not found.
 * RET offset           The offset of the container structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_CONTAINER
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  name = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  READ_LONG 0x70 ofsContainers
  READ_SHORT 0x74 numContainers
  FOR (idx = 0; idx < numContainers; ++idx) BEGIN
    SET curOfs = ofsContainers + (idx * 0xc0)
    READ_ASCII curOfs curName ( 32 ) NULL
    PATCH_IF (~%curName%~ STRING_EQUAL_CASE ~%name%~) BEGIN
      PATCH_IF (skip <= 0) BEGIN
        SET index = idx
        SET offset = curOfs
        SET idx = numContainers
      END ELSE BEGIN
        SET skip -= 1
      END
    END
  END
END

/** ARE_INDEX_OF_CONTAINER_ITEM
 * Attempts to determine the index of an ARE container item structure.
 * INT_VAR defaultIndex Returned if no container matches the specified name.
 * INT_VAR skip         Set to the number of skipped matches, in case you don't want the first matching container to be returned. (Default: 0)
 * STR_VAR resource     Item resource to find.
 * RET index            The item index if found, or defaultIndex if not found.
 * RET offset           The offset of the item structure if found, or -1 if not found.
 */
DEFINE_PATCH_FUNCTION ARE_INDEX_OF_CONTAINER_ITEM
INT_VAR
  defaultIndex = "-1"
  skip = 0
STR_VAR
  resource = ~~
RET
  index
  offset
BEGIN
  SET index = defaultIndex
  SET offset = "-1"
  PATCH_IF (NOT ~%resource%~ STRING_EQUAL ~~) BEGIN
    READ_SHORT 0x76 numItems
    READ_LONG 0x78 ofsItems
    FOR (idx = 0; idx < numItems; ++idx) BEGIN
      SET curOfs = ofsItems + (idx * 0x14)
      READ_ASCII curOfs curRes ( 8 ) NULL
      PATCH_IF (~%curRes%~ STRING_EQUAL_CASE ~%resource%~) BEGIN
        PATCH_IF (skip <= 0) BEGIN
          SET index = idx
          SET offset = curOfs
          SET idx = numItems
        END ELSE BEGIN
          SET skip -= 1
        END
      END
    END
  END
END


/** DISTRIBUTE_ITEMS
 * Distributes items as defined in a 2DA table structure.
 * STR_VAR table  Full path to the item table.
 */
DEFINE_ACTION_FUNCTION DISTRIBUTE_ITEMS
STR_VAR
  table = ~~
BEGIN
  ACTION_IF (FILE_EXISTS ~%table%~) BEGIN
    COPY - ~%table%~ ~%table%~
      EVALUATE_BUFFER
      COUNT_2DA_ROWS 7 numRows
      FOR (idx = 0; idx < numRows; ++idx) BEGIN
        READ_2DA_ENTRY idx 0 7 type
        READ_2DA_ENTRY idx 1 7 res
        READ_2DA_ENTRY idx 2 7 name
        READ_2DA_ENTRY idx 3 7 item
        READ_2DA_ENTRY idx 4 7 count
        READ_2DA_ENTRY idx 5 7 count2
        READ_2DA_ENTRY idx 6 7 count3
        INNER_ACTION BEGIN
          ACTION_IF (~%type%~ STRING_EQUAL_CASE ~ACTOR~) BEGIN
            ACTION_IF (FILE_EXISTS_IN_GAME ~%res%.cre~) BEGIN
              COPY_EXISTING ~%res%.cre~ ~override~
                PATCH_IF (~%name%~ STRING_EQUAL_CASE ~*~) BEGIN TEXT_SPRINT name ~NONE~ END
                ADD_CRE_ITEM ~%item%~ (count) (count2) (count3) ~%name%~ ~INV1 INV2 INV3 INV4 INV5 INV6 INV7 INV8 INV9 INV10 INV11 INV12 INV13 INV14 INV15 INV16 QITEM1 QITEM2 QITEM3 QUIVER1 QUIVER2 QUIVER3 QUIVER4~
              BUT_ONLY
            END
          END ELSE ACTION_IF (~%type%~ STRING_EQUAL_CASE ~STORE~ OR ~%type%~ STRING_EQUAL_CASE ~STORE+~) BEGIN
            ACTION_IF (FILE_EXISTS_IN_GAME ~%res%.sto~) BEGIN
              COPY_EXISTING ~%res%.sto~ ~override~
                TO_UPPER name
                PATCH_MATCH ~%name%~ WITH
                  ~IDENTIFIED~ ~UNSTEALABLE~ ~STOLEN~ ~IDENTIFIED&STOLEN~ ~IDENTIFIED&UNSTEALABLE~
                  BEGIN
                  END
                  ~*~
                  BEGIN
                    TEXT_SPRINT name ~IDENTIFIED~
                  END
                  DEFAULT
                    TEXT_SPRINT name ~NONE~
                END
                PATCH_IF (~%type%~ STRING_EQUAL_CASE ~STORE~) BEGIN
                  ADD_STORE_ITEM ~%item%~ LAST (count2) (count3) (0) ~%name%~ (count)
                END ELSE BEGIN
                  ADD_STORE_ITEM + ~%item%~ LAST (count2) (count3) (0) ~%name%~ (count)
                END
              BUT_ONLY
            END
          END ELSE ACTION_IF (~%type%~ STRING_EQUAL_CASE ~CONTAINER~) BEGIN
            ACTION_IF (FILE_EXISTS_IN_GAME ~%res%.ARE~) BEGIN
              COPY_EXISTING ~%res%.ARE~ ~override~
                INNER_PATCH_SAVE name ~%name%~ BEGIN REPLACE_TEXTUALLY EXACT_MATCH ~*~ ~ ~ END
                LPF ARE_INDEX_OF_CONTAINER STR_VAR name = EVAL ~%name%~ RET index END
                PATCH_IF (index >= 0) BEGIN
                  LPF fj_are_structure
                  INT_VAR
                    fj_con_itm_idx    = index
                    fj_charge0        = count
                    fj_charge1        = count2
                    fj_charge2        = count3
                  STR_VAR
                    fj_structure_type = "itm"
                    fj_name           = EVAL "%item%"
                  END
                END
              BUT_ONLY
            END
          END
        END
      END
  END
END


/** APPLY_GOLEM_TINT_BRIGHT
 * Adds the specified bright tint (opcode 52) to the current CRE resource 
 * unless it has been recolored already.
 */
DEFINE_PATCH_FUNCTION APPLY_GOLEM_TINT_BRIGHT
INT_VAR
  rgb = 0
BEGIN
  READ_ASCII 0 sig (8)
  PATCH_IF (~%sig%~ STRING_EQUAL ~CRE V1.0~) BEGIN
    // checking for existing color effects
    READ_BYTE 0x33 version
    READ_LONG 0x2c4 ofsEffects
    READ_SHORT 0x2c8 numEffects
    SET sizeEffect = (version = 1) ? 0x108 : 0x30
    SET match = 0
    FOR (idx = 0; idx < numEffects; idx += 1) BEGIN
      SET curOfs = ofsEffects + (idx * sizeEffect)
      PATCH_IF (version = 1) BEGIN
        READ_LONG (curOfs + 8) opcode
      END ELSE BEGIN
        READ_SHORT curOfs opcode
      END
      PATCH_IF (opcode = 51 OR opcode = 52) BEGIN
        SET match = 1
        SET idx = numEffects
      END
    END

    // applying effects
    PATCH_IF (NOT match) BEGIN
      // Adding color tint
      LPF ADD_CRE_EFFECT
      INT_VAR
        opcode = 52             // Character tint bright
        timing = 9              // Instant/Permanent
        target = 1              // Self
        parameter1  = rgb
        parameter2  = 2         // Location = Major color
      END
      PATCH_FOR_EACH param2 IN ~9~ ~50~ BEGIN
        // Protecting original color tint
        LPF ADD_CRE_EFFECT
        INT_VAR
          opcode = 101  // Immunity to effect
          timing = 9    // Instant/Permanent
          target = 1    // Self
          parameter2  = param2
        END
      END
    END
  END
END

/** APPLY_STONE_GOLEM_TINT
 * Adds "Stone Golem" color effect to the current CRE resource unless it has 
 * been recolored already.
 */
DEFINE_PATCH_FUNCTION APPLY_STONE_GOLEM_TINT
BEGIN
  // RGB(4,7,7)
  LPF APPLY_GOLEM_TINT_BRIGHT INT_VAR rgb = 0x7070400 END
END

/** APPLY_BRAIN_GOLEM_TINT
 * Adds "Brain Golem" color effect to the current CRE resource unless it has 
 * been recolored already.
 */
DEFINE_PATCH_FUNCTION APPLY_BRAIN_GOLEM_TINT
BEGIN
  // RGB(14,12,8)
  LPF APPLY_GOLEM_TINT_BRIGHT INT_VAR rgb = 0x080c0e00 END
END


/** APPLY_SPELL_STATE
 * Adds an opcode to set a specific spell state to the current creature or spell resource.
 */
DEFINE_PATCH_FUNCTION APPLY_SPELL_STATE
INT_VAR
  splstate  = "-1"
BEGIN
  PATCH_IF (splstate >= 0) BEGIN
    READ_ASCII 0 sig (8)
    PATCH_IF (~%sig%~ STRING_EQUAL ~CRE V1.0~) BEGIN
      LPF ADD_CRE_EFFECT
      INT_VAR
        opcode  = 328     // Set spell state
        timing  = 9       // Instant/Permanent
        target  = 1       // Self
        parameter2  = splstate
        special = 1       // IWD2 mode
      END
    END ELSE PATCH_IF (~%sig%~ STRING_EQUAL ~SPL V1  ~) BEGIN
      LPF ADD_SPELL_EFFECT
      INT_VAR
        opcode  = 328
        timing  = 9       // Instant/Permanent
        target  = 2       // Preset target
        parameter2    = splstate
        resist_dispel = 2
        special = 1       // IWD2 mode
      END
    END
  END
END


/** REMOVE_SPELL_STATE
 * Removes the specified spell state from the current creature or spell resource.
 */
DEFINE_PATCH_FUNCTION REMOVE_SPELL_STATE
INT_VAR
  splstate = "-1"
BEGIN
  READ_ASCII 0 sig (8)
  PATCH_IF (~%sig%~ STRING_EQUAL ~CRE V1.0~) BEGIN
    LPF ADD_CRE_EFFECT
    INT_VAR
      opcode  = 337     // Remove opcode
      timing  = 9       // Instant/Permanent
      target  = 1       // Self
      parameter1  = splstate
      parameter2  = 328 // Opcode: Set Spell State
    END
  END ELSE PATCH_IF (~%sig%~ STRING_EQUAL ~SPL V1  ~) BEGIN
    LPF ADD_SPELL_EFFECT
    INT_VAR
      opcode  = 337
      timing  = 9       // Instant/Permanent
      target  = 2       // Preset target
      parameter1  = splstate
      parameter2  = 328 // Opcode: Set Spell State
      resist_dispel = 2
    END
  END
END


/** GET_2DA_ENTRY_OF
 * Returns column and row index of the 2DA entry that matches the specified search text of the given 2da file.
 */
DEFINE_PATCH_FUNCTION GET_2DA_ENTRY_OF
INT_VAR
  row_match = "-1"  // neg. value indicates to search all rows
  col_match = "-1"  // neg. value indicates to search all columns
STR_VAR
  file          = ~~  // the 2da filename
  entry_match   = ~~  // search text
RET
  row col
BEGIN
  SET row = "-1"
  SET col = "-1"
  INNER_ACTION BEGIN
    COPY_EXISTING - ~%file%~ ~override~
      COUNT_2DA_COLS numCols
      COUNT_2DA_ROWS numCols numRows
      SET rowOffset = (numCols = 1 || numCols = 2) ? 1 : 0  // to compensate for 2DA headers
      SET rowMin = (row_match < 0) ? 0 : row_match
      SET rowMax = (row_match < 0) ? (numRows - 1) : row_match
      SET colMin = (col_match < 0) ? 0 : col_match
      SET colMax = (col_match < 0) ? (numCols - 1) : col_match
      FOR (curRow = rowMin + rowOffset; curRow <= rowMax; ++curRow) BEGIN
        FOR (curCol = colMin; curCol <= colMax; ++curCol) BEGIN
          READ_2DA_ENTRY curRow curCol numCols value
          PATCH_IF (~%entry_match%~ STR_EQ ~%value%~) BEGIN
            SET row = curRow - rowOffset
            SET col = curCol
            SET curRow = rowMax + 1
            SET curCol = colMax + 1
          END
        END
      END
    IF_EXISTS
  END
END

//BLOCK ITM_TO_CONTAINER
DEFINE_PATCH_FUNCTION ADD_ITEM_TO_CONTAINER
INT_VAR
  expiry_time = 0
  charge0 = 0
  charge1 = 0
  charge2 = 0
STR_VAR
  itm_name = ""
  cont_name = ""
  //flags = ""
BEGIN
  /*PATCH_MATCH ~%flags%~ WITH
    ~IDENTIFIED~
    BEGIN
      flg = 1
    END
    ~UNSTEALABLE~
    BEGIN
      flg = 2
    END
    ~STOLEN~
    BEGIN
      flg = 4
    END
    ~IDENTIFIED&STOLEN~
    BEGIN
      flg = 5
    END
    ~IDENTIFIED&UNSTEALABLE~
    BEGIN
      flg = 3
    END    
    DEFAULT
      flg = 0
  END  */
  LPF ARE_INDEX_OF_CONTAINER STR_VAR name = EVAL ~%cont_name%~ RET index END  
  PATCH_IF (index >= 0) THEN BEGIN
    LPF fj_are_structure
    INT_VAR
      fj_con_itm_idx = index
      fj_itm_expiry = expiry_time
      fj_charge0 = charge0
      fj_charge1 = charge1
      fj_charge2 = charge2
     // fj_flags = flg
    STR_VAR
      fj_structure_type = "itm"
      fj_name = EVAL "%itm_name%"
    END
  END
END

DEFINE_ACTION_FUNCTION ADD_ITEM_TO_CONTAINER
INT_VAR
  expiry_time = 0
  charge0 = 0
  charge1 = 0
  charge2 = 0
STR_VAR
  area = ""
  itm_name = ""
  cont_name = ""
BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME ~%area%.are~ THEN BEGIN
    COPY_EXISTING ~%area%.are~ ~override~
      LPF ADD_ITEM_TO_CONTAINER
        INT_VAR expiry_time = expiry_time charge0 = charge0 charge1 = charge1 charge2 = charge2
        STR_VAR itm_name = EVAL ~%itm_name%~ cont_name = EVAL ~%cont_name%~
      END
  END
END
//BLOCKEND

//BLOCK CRE_TO_AREA
DEFINE_PATCH_FUNCTION ~add_area_cre_acti~
  INT_VAR
    pos_x       =   1
    pos_y       =   1
    dest_x      =   ~%pos_x%~
    dest_y      =   ~%pos_y%~
    flags       =   1
    anim        =   25602
    dir         =   0
    //unknown     =   0xff
    expiri_time = ~-1~
    wander_dist =   0
    follow_dist =   0
    present_at  =   0b11111111111111111111111111111111
    talked_to   =   0
    position    =   0
  STR_VAR
    //area_name   = ""
    actor_name  = ""
    dialogue    = ""
    over_scr    = ""
    genr_scr    = ""
    clas_scr    = ""
    race_scr    = ""
    defl_scr    = ""
    spec_scr    = ""
    cre_file    = ""
  RET
    position
    offset
BEGIN
    //BLOCK
    //COPY_EXISTING ~%area_name%.are~ ~override~
      READ_LONG   0x54 actor_off
      READ_SHORT  0x58 actor_num
      WRITE_SHORT 0x58 ~%actor_num%~ + 1
      READ_LONG   0x5c triggers_off
      PATCH_IF (~%triggers_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x5c ~%triggers_off%~ + 0x110
      END
      READ_LONG   0x60 spawn_off
      PATCH_IF (~%spawn_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x60 ~%spawn_off%~ + 0x110
      END
      READ_LONG   0x68 entrance_off
      PATCH_IF (~%entrance_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x68 ~%entrance_off%~ + 0x110
      END
      READ_LONG   0x70 contain_off
      PATCH_IF (~%contain_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x70 ~%contain_off%~ + 0x110
      END
      READ_LONG   0x78 item_off
      PATCH_IF (~%item_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x78 ~%item_off%~ + 0x110
      END
      READ_LONG   0x7c vert_off
      PATCH_IF (~%vert_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x7c ~%vert_off%~ + 0x110
      END
      READ_LONG   0x84 ambi_off
      PATCH_IF (~%ambi_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x84 ~%ambi_off%~ + 0x110
      END
      READ_LONG   0x88 var_off
      PATCH_IF (~%var_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0x88 ~%var_off%~ + 0x110
      END
      READ_LONG   0xa0 explore_off
      PATCH_IF (~%explore_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xa0 ~%explore_off%~ + 0x110
      END
      READ_LONG   0xa8 door_off
      PATCH_IF (~%door_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xa8 ~%door_off%~ + 0x110
      END
      READ_LONG   0xb0 anim_off
      PATCH_IF (~%anim_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xb0 ~%anim_off%~ + 0x110
      END
      READ_LONG   0xb8 tiled_off
      PATCH_IF (~%tiled_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xb8 ~%tiled_off%~ + 0x110
      END
      READ_LONG   0xbc song_off
      PATCH_IF (~%song_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xbc ~%song_off%~ + 0x110
      END
      READ_LONG   0xc0 rest_enc_off
      PATCH_IF (~%rest_enc_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xc0 ~%rest_enc_off%~ + 0x110
      END
      READ_LONG   0xc4 auto_map_off
      PATCH_IF (~%auto_map_off%~ >= ~%actor_off%~) BEGIN
        WRITE_LONG 0xc4 ~%auto_map_off%~ + 0x110
      END
    //BLOCKEND
    //position += 1
    PATCH_IF (position > actor_num) THEN BEGIN
      position = actor_num
    END
    offset = ~%actor_off%~ + 0x110 * ~%position%~
    
      INSERT_BYTES ~%offset%~ 0x110
        WRITE_ASCIIE ~%offset%~ + 0x00 ~%actor_name%~ (32)
        WRITE_SHORT  ~%offset%~ + 0x20 ~%pos_x%~
        WRITE_SHORT  ~%offset%~ + 0x22 ~%pos_y%~
        WRITE_SHORT  ~%offset%~ + 0x24 ~%dest_x%~
        WRITE_SHORT  ~%offset%~ + 0x26 ~%dest_y%~
        WRITE_BYTE   ~%offset%~ + 0x28 ~%flags%~
        WRITE_LONG   ~%offset%~ + 0x30 ~%anim%~
        WRITE_SHORT  ~%offset%~ + 0x34 ~%dir%~
        //WRITE_BYTE   ~%actor_off%~ + 0x36 ~%unknown%~
        WRITE_LONG   ~%offset%~ + 0x38 ~%expiri_time%~
        WRITE_SHORT  ~%offset%~ + 0x3c ~%wander_dist%~
        WRITE_SHORT  ~%offset%~ + 0x3e ~%follow_dist%~
        WRITE_LONG   ~%offset%~ + 0x40 ~%present_at%~
        WRITE_LONG   ~%offset%~ + 0x44 ~%talked_to%~
        WRITE_ASCIIE ~%offset%~ + 0x48 ~%dialogue%~ (8)
        WRITE_ASCIIE ~%offset%~ + 0x50 ~%over_scr%~ (8)
        WRITE_ASCIIE ~%offset%~ + 0x58 ~%genr_scr%~ (8)
        WRITE_ASCIIE ~%offset%~ + 0x60 ~%clas_scr%~ (8)
        WRITE_ASCIIE ~%offset%~ + 0x68 ~%race_scr%~ (8)
        WRITE_ASCIIE ~%offset%~ + 0x70 ~%defl_scr%~ (8)
        WRITE_ASCIIE ~%offset%~ + 0x78 ~%spec_scr%~ (8)
        WRITE_ASCIIE ~%offset%~ + 0x80 ~%cre_file%~ (8)
END

DEFINE_ACTION_FUNCTION ~add_area_cre_acti~
  INT_VAR
    pos_x       =   1
    pos_y       =   1
    dest_x      =   ~%pos_x%~
    dest_y      =   ~%pos_y%~
    flags       =   1
    anim        =   25602
    dir         =   0
    //unknown     =   0xff
    expiri_time = ~-1~
    wander_dist =   0
    follow_dist =   0
    present_at  =   0b11111111111111111111111111111111
    talked_to   =   0
    position    =   0
  STR_VAR
    area        = ""
    actor_name  = ""
    dialogue    = ""
    over_scr    = ""
    genr_scr    = ""
    clas_scr    = ""
    race_scr    = ""
    defl_scr    = ""
    spec_scr    = ""
    cre_file    = ""
  RET
    position
    offset
BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME ~%area%.are~ THEN BEGIN
    COPY_EXISTING ~%area%.are~ ~override~
      LPF add_area_cre_acti
        INT_VAR
          pos_x       =   pos_x
          pos_y       =   pos_y
          dest_x      =   dest_x
          dest_y      =   dest_y
          flags       =   flags
          anim        =   anim
          dir         =   dir
          //unknown     =   0xff
          expiri_time =   expiri_time
          wander_dist =   wander_dist
          follow_dist =   follow_dist
          present_at  =   present_at
          talked_to   =   talked_to
          position    =   position
        STR_VAR
          actor_name  = EVAL ~%actor_name%~
          dialogue    = EVAL ~%dialogue%~
          over_scr    = EVAL ~%over_scr%~
          genr_scr    = EVAL ~%genr_scr%~
          clas_scr    = EVAL ~%clas_scr%~
          race_scr    = EVAL ~%race_scr%~
          defl_scr    = EVAL ~%defl_scr%~
          spec_scr    = EVAL ~%spec_scr%~
          cre_file    = EVAL ~%cre_file%~
        RET
          position
          offset
      END
  END
END
//BLOCKEND

//BLOCK ITEMS

//BLOCK EMPTY ITEM
DEFINE_ACTION_FUNCTION CREATE_EMPTY_ITEM_ACTI
INT_VAR
  gen_name    = "-1"  //0x08 LONG
  id_name     = "-1"  //0x0c LONG
  flags       = 0     //0x18 LONG
  type        = 0     //0x1c SHORT
  usability   = 0     //0x1e LONG
  min_level   = 0     //0x24 SHORT
  min_str     = 0     //0x26 SHORT
  min_str_bon = 0     //0x28 BYTE
  kit_use_1   = 0     //0x29 BYTE
  min_int     = 0     //0x2a BYTE
  kit_use_2   = 0     //0x2b BYTE
  min_dex     = 0     //0x2c BYTE
  kit_use_3   = 0     //0x2d BYTE
  min_wis     = 0     //0x2e BYTE
  kit_use_4   = 0     //0x2f BYTE
  min_con     = 0     //0x30 BYTE
  prof        = 0     //0x31 BYTE 0. 0x59 - 0x86
  min_cha     = 0     //0x32 SHORT
  price       = 0     //0x34 LONG
  stack       = 0     //0x38 SHORT
  lore        = 0     //0x42 SHORT
  weight      = 0     //0x4c LONG
  unid_desc   = "-1"  //0x50 LONG
  id_desc     = "-1"  //0x54 LONG
  enchant     = 0     //0x60 LONG
STR_VAR
  name        = "empty"
  directory   = ""
  used_up     = ""    //0x10 ASCII
  itm_anim    = ""    //0x22 SHORT ( IESDP)
  icon_inv    = ""    //0x3a ASCII
  icon_ground = ""    //0x44 ASCII
  icon_desc   = ""    //0x58 ASCII
RET

BEGIN
  ACTION_IF (~%directory%~ STRING_EQUAL ~~) BEGIN
    OUTER_SPRINT ~directory~ ~override~
  END ELSE BEGIN
    MKDIR ~%directory%~
  END
  ACTION_IF (min_str != 18) BEGIN OUTER_SET min_str_bon = 0 END
  ACTION_IF (prof < 89) OR (prof > 134) BEGIN OUTER_SET prof = 0 END
  ACTION_IF (type < 0) OR (type > 77) BEGIN OUTER_SET type = 0 END
<<<<<<<<itmus
>>>>>>>>
  COPY ~itmus~ ~%directory%/%name%.itm~
    INSERT_BYTES 0x00 0x72
    WRITE_ASCII  0x00 ~ITM V1  ~
      WRITE_LONG  0x08 ~%gen_name%~
      WRITE_LONG  0x0c ~%id_name%~
      WRITE_ASCII 0x10 ~%used_up%~
      WRITE_LONG  0x18 ~%flags%~
      WRITE_SHORT 0x1c ~%type%~
      WRITE_LONG  0x1e ~%usability%~
      PATCH_MATCH ~%itm_anim%~ WITH
        ~2A~ BEGIN WRITE_SHORT 0x22  12865 END
        ~3A~ BEGIN WRITE_SHORT 0x22  13121 END
        ~4A~ BEGIN WRITE_SHORT 0x22  13377 END
        ~2W~ BEGIN WRITE_SHORT 0x22  12887 END
        ~3W~ BEGIN WRITE_SHORT 0x22  13143 END
        ~4W~ BEGIN WRITE_SHORT 0x22  13399 END
        ~AX~ BEGIN WRITE_SHORT 0x22  16728 END
        ~BW~ BEGIN WRITE_SHORT 0x22  16983 END
        ~CB~ BEGIN WRITE_SHORT 0x22  17218 END
        ~CL~ BEGIN WRITE_SHORT 0x22  17228 END
        ~D1~ BEGIN WRITE_SHORT 0x22  17457 END
        ~D2~ BEGIN WRITE_SHORT 0x22  17458 END
        ~D3~ BEGIN WRITE_SHORT 0x22  17459 END
        ~D4~ BEGIN WRITE_SHORT 0x22  17460 END
        ~DD~ BEGIN WRITE_SHORT 0x22  17476 END
        ~FL~ BEGIN WRITE_SHORT 0x22  17996 END
        ~FS~ BEGIN WRITE_SHORT 0x22  18003 END
        ~H0~ BEGIN WRITE_SHORT 0x22  18480 END
        ~H1~ BEGIN WRITE_SHORT 0x22  18481 END
        ~H2~ BEGIN WRITE_SHORT 0x22  18482 END
        ~H3~ BEGIN WRITE_SHORT 0x22  18483 END
        ~H4~ BEGIN WRITE_SHORT 0x22  18484 END
        ~H5~ BEGIN WRITE_SHORT 0x22  18485 END
        ~H6~ BEGIN WRITE_SHORT 0x22  18486 END
        ~HB~ BEGIN WRITE_SHORT 0x22  18498 END
        ~MC~ BEGIN WRITE_SHORT 0x22  19779 END
        ~MS~ BEGIN WRITE_SHORT 0x22  19795 END
        ~QS~ BEGIN WRITE_SHORT 0x22  20819 END
        ~S1~ BEGIN WRITE_SHORT 0x22  21297 END
        ~S2~ BEGIN WRITE_SHORT 0x22  21298 END
        ~SL~ BEGIN WRITE_SHORT 0x22  21324 END
        ~SP~ BEGIN WRITE_SHORT 0x22  21328 END
        ~SS~ BEGIN WRITE_SHORT 0x22  21331 END
        ~WH~ BEGIN WRITE_SHORT 0x22  22344 END
        ~S3~ BEGIN WRITE_SHORT 0x22  21299 END
        ~SC~ BEGIN WRITE_SHORT 0x22  21315 END
        DEFAULT
          WRITE_SHORT 0x22 8224
      END
      WRITE_SHORT 0x24 ~%min_level%~
      WRITE_SHORT 0x26 ~%min_str%~
      WRITE_BYTE  0x28 ~%min_str_bon%~
      WRITE_BYTE  0x29 ~%kit_use_1%~
      WRITE_BYTE  0x2a ~%min_int%~
      WRITE_BYTE  0x2b ~%kit_use_2%~
      WRITE_BYTE  0x2c ~%min_dex%~
      WRITE_BYTE  0x2d ~%kit_use_3%~
      WRITE_BYTE  0x2e ~%min_wis%~
      WRITE_BYTE  0x2f ~%kit_use_4%~
      WRITE_BYTE  0x30 ~%min_con%~
      WRITE_BYTE  0x31 ~%prof%~
      WRITE_SHORT 0x32 ~%min_cha%~
      WRITE_LONG  0x34 ~%price%~
      WRITE_SHORT 0x38 ~%stack%~
      WRITE_ASCII 0x3a ~%icon_inv%~
      WRITE_SHORT 0x42 ~%lore%~
      WRITE_ASCII 0x44 ~%icon_ground%~
      WRITE_LONG  0x4c ~%weight%~
      WRITE_LONG  0x50 ~%unid_desc%~
      WRITE_LONG  0x54 ~%id_desc%~
      WRITE_ASCII 0x58 ~%icon_desc%~
      WRITE_LONG  0x60 ~%enchant%~
      WRITE_LONG  0x64 0x72
      WRITE_LONG  0x6a 0x72
END
//BLOCKEND

//BLOCK ADD_ITM_ABILIY
DEFINE_PATCH_FUNCTION ADD_ITM_ABILIY_ACTI //0x38
INT_VAR            //          off  size   value            
  position     = 3                                          
  type         = 0 //          0x00 BYTE   0-4              
  id_req       = 0 //          0x01 BYTE   0-1              
  location     = 0 //          0x02 BYTE   0-4              
  alt_dicesize = 0 //          0x03 BYTE                    
  target       = 1 //          0x0c BYTE   1-7 //not 2, 6   
  target_cnt   = 0 //          0x0d BYTE                    
  range        = 1 //          0x0e SHORT                   
  launcher     = 0 //          0x10 BYTE   0-3              
  alt_dicenum  = 0 //          0x11 BYTE                    
  speed        = 1 //          0x12 BYTE                    
  alt_dmgbon   = 0 //          0x13 BYTE                    
  tohit        = 0 //          0x14 SHORT                                                                              
  dicesize     = 0 //          0x16 BYTE                   
  primary_type = 0 //          0x17 BYTE
  dicenum      = 0 //          0x18 BYTE
  sec_type     = 0 //          0x19 BYTE
  dmgbon       = 0 //          0x1a SHORT
  dmgtype      = 0 //          0x1c SHORT  0-8
  charges      = 0 //          0x22 SHORT
  drained      = 0 //          0x24 SHORT
  flags        = 0 //          0x26 LONG
  projectile   = 0 //          0x2a SHORT
  ranged_type  = 0 //               SHORT : 0x32 - 1 - arrow; 0x34 - 2 - bolt ; 0x36 - 3 - bullet
STR_VAR
  icon       = ""        //    0x04 ASCII
  melee_anim = "000000"  //    0x2c, 0x2e, 0x30 - in HEX - SHORT - overhand / backhand / thrust
RET
  position
BEGIN
  READ_SHORT 0x68 abil_num
  PATCH_IF (abil_num < 3) BEGIN
    READ_LONG 0x64 abil_off
    PATCH_IF (position > abil_num) BEGIN SET position = abil_num END
    PATCH_IF (type < 0) OR (type > 4) BEGIN SET type = 0 END
    PATCH_IF (id_req < 0) OR (id_req > 1) BEGIN SET id_req = 0 END
    PATCH_IF (location < 0) OR (location > 4) BEGIN SET location = 0 END
    PATCH_IF (target < 1) OR (target > 7) BEGIN SET target = 1 END
    PATCH_IF (target = 2) OR (target = 6) BEGIN SET target = 1 END
    PATCH_IF (launcher < 0) OR (launcher > 3) BEGIN SET launcher = 0 END
    PATCH_IF (dmgtype < 0) OR (dmgtype > 8) BEGIN SET dmgtype = 0 END
    PATCH_IF (ranged_type < 0) OR (ranged_type > 3) BEGIN SET ranged_type = 0 END    
    SPRINT ~man1~ ~melee_anim~
    SPRINT ~man2~ ~melee_anim~
    SPRINT ~man3~ ~melee_anim~
    INNER_PATCH_SAVE ~man1~ ~%man1%~ BEGIN DELETE_BYTES 0x02 4 END
    INNER_PATCH_SAVE ~man2~ ~%man2%~ BEGIN DELETE_BYTES 0x04 2 DELETE_BYTES 0x00 2 END
    INNER_PATCH_SAVE ~man3~ ~%man3%~ BEGIN DELETE_BYTES 0x00 4 END
    SPRINT ~man1~ ~0x%man1%~
    SPRINT ~man2~ ~0x%man1%~
    SPRINT ~man3~ ~0x%man1%~
    LPF TO_DEC_NUMBER STR_VAR hexNumber  = ~%man1%~ RET value END
    SET overhand = value
    LPF TO_DEC_NUMBER STR_VAR hexNumber  = ~%man2%~ RET value END
    SET backhand = value
    LPF TO_DEC_NUMBER STR_VAR hexNumber  = ~%man3%~ RET value END
    SET thrust = value    
    READ_LONG 0x6a eff_off
    SET abil_num = abil_num + 1
    WRITE_SHORT 0x68 abil_num
    PATCH_IF (eff_off >= abil_off) BEGIN WRITE_LONG 0x6a ~%eff_off%~ + 0x38 END
    SET offset = ~%abil_off%~ + 0x38 * ~%position%~
    INSERT_BYTES offset 0x38
      WRITE_BYTE  offset + 0x00 ~%type%~
      WRITE_BYTE  offset + 0x01 ~%id_req %~
      WRITE_BYTE  offset + 0x02 ~%location%~
      WRITE_BYTE  offset + 0x03 ~%alt_dicesize%~
      WRITE_ASCII offset + 0x04 ~%icon%~
      WRITE_BYTE  offset + 0x0c ~%target%~
      WRITE_BYTE  offset + 0x0d ~%target_cnt%~
      WRITE_SHORT offset + 0x0e ~%range%~
      WRITE_BYTE  offset + 0x10 ~%launcher%~   
      WRITE_BYTE  offset + 0x11 ~%alt_dicenum%~
      WRITE_BYTE  offset + 0x12 ~%speed%~      
      WRITE_BYTE  offset + 0x13 ~%alt_dmgbon%~ 
      WRITE_SHORT offset + 0x14 ~%tohit%~
      WRITE_BYTE  offset + 0x16 ~%dicesize%~        
      WRITE_BYTE  offset + 0x17 ~%primary_type%~    
      WRITE_BYTE  offset + 0x18 ~%dicenum%~         
      WRITE_BYTE  offset + 0x19 ~%sec_type%~        
      WRITE_SHORT offset + 0x1a ~%dmgbon%~
      WRITE_SHORT offset + 0x1c ~%dmgtype%~
      WRITE_SHORT offset + 0x22 ~%charges%~
      WRITE_SHORT offset + 0x24 ~%drained%~
      WRITE_BYTE  offset + 0x26 ~%flags%~
      WRITE_SHORT offset + 0x2a ~%projectile%~
      WRITE_SHORT offset + 0x2c ~%overhand%~
      WRITE_SHORT offset + 0x2a ~%backhand%~
      WRITE_SHORT offset + 0x30 ~%thrust%~
      PATCH_MATCH ~%ranged_type%~ WITH
        1
        BEGIN
          WRITE_SHORT offset + 0x32 1
        END
        2
        BEGIN
          WRITE_SHORT offset + 0x34 1 
        END
        3
        BEGIN
          WRITE_SHORT offset + 0x36 1
        END
        DEFAULT
          WRITE_SHORT offset + 0x32 0
      END
  END
END

DEFINE_ACTION_FUNCTION ADD_ITM_ABILIY_ACTI //0x38
INT_VAR            //          off  size   value            
  position     = 3                                          
  type         = 0 //          0x00 BYTE   0-4              
  id_req       = 0 //          0x01 BYTE   0-1              
  location     = 0 //          0x02 BYTE   0-4              
  alt_dicesize = 0 //          0x03 BYTE                    
  target       = 1 //          0x0c BYTE   1-7 //not 2, 6   
  target_cnt   = 0 //          0x0d BYTE                    
  range        = 1 //          0x0e SHORT                   
  launcher     = 0 //          0x10 BYTE   0-3              
  alt_dicenum  = 0 //          0x11 BYTE                    
  speed        = 1 //          0x12 BYTE                    
  alt_dmgbon   = 0 //          0x13 BYTE                    
  tohit        = 0 //          0x14 SHORT                                                                              
  dicesize     = 0 //          0x16 BYTE                   
  primary_type = 0 //          0x17 BYTE
  dicenum      = 0 //          0x18 BYTE
  sec_type     = 0 //          0x19 BYTE
  dmgbon       = 0 //          0x1a SHORT
  dmgtype      = 0 //          0x1c SHORT  0-8
  charges      = 0 //          0x22 SHORT
  drained      = 0 //          0x24 SHORT
  flags        = 0 //          0x26 LONG
  projectile   = 0 //          0x2a SHORT
  ranged_type  = 0 //               SHORT : 0x32 - 1 - arrow; 0x34 - 2 - bolt ; 0x36 - 3 - bullet
STR_VAR
  item       = ""
  icon       = ""        //    0x04 ASCII
  melee_anim = "000000"  //    0x2c, 0x2e, 0x30 - in HEX - SHORT - overhand / backhand / thrust
RET
  position
BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME ~%item%.are~ THEN BEGIN
    COPY_EXISTING ~%item%.are~ ~override~
      LPF ADD_ITM_ABILIY_ACTI
        INT_VAR           
          position     = position
          type         = type
          id_req       = id_req
          location     = location
          alt_dicesize = alt_dicesize
          target       = target
          target_cnt   = target_cnt
          range        = range
          launcher     = launcher
          alt_dicenum  = alt_dicenum
          speed        = speed
          alt_dmgbon   = alt_dmgbon
          tohit        = tohit            
          dicesize     = dicesize
          primary_type = primary_type
          dicenum      = dicenum
          sec_type     = dicenum
          dmgbon       = dmgbon
          dmgtype      = dmgtype
          charges      = charges
          drained      = drained
          flags        = flags
          projectile   = projectile
          ranged_type  = ranged_type
        STR_VAR
          icon       = EVAL ~%icon%~
          melee_anim = EVAL ~%melee_anim%~
        RET
          position
      END
  END
END
//BLOCKEND

//BLOCK ADD_ITEM_EFFECT
DEFINE_PATCH_FUNCTION ADD_ITEM_EFFECT_ACTI //30
INT_VAR
  position = 9999
  opcode   = 0    //0x00 SHORT
  target   = 0    //0x02 BYTE   0-9
  power    = 0    //0x03 BYTE
  param1   = 0    //0x04 LONG
  param2   = 0    //0x08 LONG
  timing   = 0    //0x0c BYTE   0-10, 4096
  resist   = 0    //0x0d BYTE
  duration = 0    //0x0e LONG
  prob1    = 100  //0x12 BYTE
  prob2    = 0    //0x13 BYTE
  dicenum  = 0    //0x1c LONG
  dicesize = 0    //0x20 LONG
  saveint  = "-1" //0x24 LONG
  savebon  = 0    //0x28 LONG
  special  = 0    //0x2c LONG
STR_VAR
  resource = ""   //0x14 ASCII
  saves    = ""   //SPELL, BREATH, DEATH, WANDS, POLYMORPH - 0x24 LONG
RET
  position
BEGIN
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a eff_off
  READ_SHORT 0x6e first_effect
  READ_SHORT 0x70 eff_num
  
  PATCH_IF (target < 0) OR (target > 9) BEGIN SET target = 0 END
  PATCH_MATCH ~%timing%~ WITH
    0 1 2 3 4 5 6 7 8 9 10 4096
    BEGIN
    END
    DEFAULT
      timing = 0
  END
  
  PATCH_IF (first_effect > 0) BEGIN SET no_abil = 1 END ELSE BEGIN SET no_abil = 0 END
  PATCH_IF (no_abil = 1) BEGIN
    SET offset = first_effect * 0x30
  END ELSE BEGIN
    SET offset = eff_off
    PATCH_IF (abil_num > 0) BEGIN
      FOR ( i = 0 ; i < abil_num ; ++i ) BEGIN
        READ_SHORT  abil_off + 0x38 * i + 0x20 a_eff
        WRITE_SHORT abil_off + 0x38 * i + 0x20 ~%a_eff%~ + 1
      END
    END
  END
  WRITE_SHORT 0x70 ~%eff_num%~ + 1
  PATCH_IF (abil_off >= eff_off) BEGIN WRITE_LONG 0x6a ~%eff_off%~ + 0x30 END
  PATCH_IF (position > eff_num) BEGIN SET position = eff_num END
  SET offset = offset + 0x30 * position
  INSERT_BYTES offset 0x30
    WRITE_SHORT offset + 0x00 ~%opcode%~
    WRITE_BYTE  offset + 0x02 ~%target%~
    WRITE_BYTE  offset + 0x03 ~%power%~
    WRITE_LONG  offset + 0x04 ~%param1%~
    WRITE_LONG  offset + 0x08 ~%param2%~
    WRITE_BYTE  offset + 0x0c ~%timing%~
    WRITE_BYTE  offset + 0x0d ~%resist%~
    WRITE_LONG  offset + 0x0e ~%duration%~
    WRITE_BYTE  offset + 0x12 ~%prob1%~
    WRITE_BYTE  offset + 0x13 ~%prob2%~
    WRITE_ASCII offset + 0x14 ~%resource%~
    WRITE_LONG  offset + 0x1c ~%dicenum%~
    WRITE_LONG  offset + 0x20 ~%dicesize%~
    PATCH_IF (saveint >= 0) BEGIN
      WRITE_LONG offset + 0x24 ~%saveint%~
    END ELSE BEGIN
      PATCH_MATCH ~%saves%~ WITH
        ~SPELL~
        BEGIN
          WRITE_LONG 0x24 1
        END
        ~BREATH~
        BEGIN
          WRITE_LONG 0x24 2
        END
        ~DEATH~
        BEGIN
          WRITE_LONG 0x24 4
        END
        ~WANDS~
        BEGIN
          WRITE_LONG 0x24 8
        END
        ~POLYMORPH~
        BEGIN
          WRITE_LONG 0x24 16
        END
        DEFAULT
          WRITE_LONG 0x24 0
      END
    END  
    WRITE_LONG  offset + 0x28 ~%savebon%~
    WRITE_LONG  offset + 0x2c ~%special%~
END

DEFINE_ACTION_FUNCTION ADD_ITEM_EFFECT_ACTI //30
INT_VAR
  position = 9999
  opcode   = 0    //0x00 SHORT
  target   = 0    //0x02 BYTE   0-9
  power    = 0    //0x03 BYTE
  param1   = 0    //0x04 LONG
  param2   = 0    //0x08 LONG
  timing   = 0    //0x0c BYTE   0-10, 4096
  resist   = 0    //0x0d BYTE
  duration = 0    //0x0e LONG
  prob1    = 100  //0x12 BYTE
  prob2    = 0    //0x13 BYTE
  dicenum  = 0    //0x1c LONG
  dicesize = 0    //0x20 LONG
  saveint  = "-1" //0x24 LONG
  savebon  = 0    //0x28 LONG
  special  = 0    //0x2c LONG
STR_VAR
  item     = ""
  resource = ""   //0x14 ASCII
  saves    = ""   //SPELL, BREATH, DEATH, WANDS, POLYMORPH - 0x24 LONG
RET
  position
BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME ~%item%.are~ THEN BEGIN
    COPY_EXISTING ~%item%.are~ ~override~
      LPF ADD_ITM_ABILIY_ACTI
        INT_VAR
          position = position
          opcode   = opcode
          target   = target
          power    = power
          param1   = param1
          param2   = param2
          timing   = timing
          resist   = resist
          duration = duration
          prob1    = prob1
          prob2    = prob2
          dicenum  = dicenum
          dicesize = dicesize
          saveint  = saveint
          savebon  = savebon
          special  = special
        STR_VAR
          resource = EVAL ~%resource%~
          saves    = EVAL ~%saves%~
        RET
          position
      END
  END
END
//BLOCKEND

//BLOCK ADD_ITEM_ABIL_EFFECT
DEFINE_PATCH_FUNCTION ADD_ITEM_ABIL_EFFECT_ACTI_EX
INT_VAR
  position = 9999
  abils    = 0 //Abilities count
  abil_nm  = 0 //Abil number
  offsetA  = 0 //Offset to current ability
  eff_off  = 0 //offset to first effect in current ability
  no_abil  = 0 //Global effects after abilities
  opcode   = 0    //0x00 SHORT
  target   = 0    //0x02 BYTE   0-9
  power    = 0    //0x03 BYTE
  param1   = 0    //0x04 LONG
  param2   = 0    //0x08 LONG
  timing   = 0    //0x0c BYTE   0-10, 4096
  resist   = 0    //0x0d BYTE
  duration = 0    //0x0e LONG
  prob1    = 100  //0x12 BYTE
  prob2    = 0    //0x13 BYTE
  dicenum  = 0    //0x1c LONG
  dicesize = 0    //0x20 LONG
  saveint  = "-1" //0x24 LONG
  savebon  = 0    //0x28 LONG
  special  = 0    //0x2c LONG
STR_VAR
  resource = ""   //0x14 ASCII
  saves    = ""   //SPELL, BREATH, DEATH, WANDS, POLYMORPH - 0x24 LONG
RET
  position
BEGIN
  READ_SHORT  offsetA + 0x1e eff_cnt
  WRITE_SHORT offsetA + 0x1e ~%eff_cnt%~ + 1
  PATCH_IF (position > eff_cnt) BEGIN SET position = eff_cnt END
  FOR ( i = abil_nm + 1 ; i < abils ; ++i ) BEGIN
    READ_SHORT  offsetA + 0x38 * i + 0x20 nm
    WRITE_SHORT offsetA + 0x38 * i + 0x20 ~%nm%~ + 1
    PATCH_IF (no_abil > 0) BEGIN
      READ_SHORT  0x6e nm
      WRITE_SHORT 0x6e ~%nm%~ + 1
    END
  END
  SET offset = eff_off + 0x30 * position
  INSERT_BYTES offset 0x30
    WRITE_SHORT offset + 0x00 ~%opcode%~
    WRITE_BYTE  offset + 0x02 ~%target%~
    WRITE_BYTE  offset + 0x03 ~%power%~
    WRITE_LONG  offset + 0x04 ~%param1%~
    WRITE_LONG  offset + 0x08 ~%param2%~
    WRITE_BYTE  offset + 0x0c ~%timing%~
    WRITE_BYTE  offset + 0x0d ~%resist%~
    WRITE_LONG  offset + 0x0e ~%duration%~
    WRITE_BYTE  offset + 0x12 ~%prob1%~
    WRITE_BYTE  offset + 0x13 ~%prob2%~
    WRITE_ASCII offset + 0x14 ~%resource%~
    WRITE_LONG  offset + 0x1c ~%dicenum%~
    WRITE_LONG  offset + 0x20 ~%dicesize%~
    PATCH_IF (saveint >= 0) BEGIN
      WRITE_LONG offset + 0x24 ~%saveint%~
    END ELSE BEGIN
      PATCH_MATCH ~%saves%~ WITH
        ~SPELL~
        BEGIN
          WRITE_LONG 0x24 1
        END
        ~BREATH~
        BEGIN
          WRITE_LONG 0x24 2
        END
        ~DEATH~
        BEGIN
          WRITE_LONG 0x24 4
        END
        ~WANDS~
        BEGIN
          WRITE_LONG 0x24 8
        END
        ~POLYMORPH~
        BEGIN
          WRITE_LONG 0x24 16
        END
        DEFAULT
          WRITE_LONG 0x24 0
      END
    END  
    WRITE_LONG  offset + 0x28 ~%savebon%~
    WRITE_LONG  offset + 0x2c ~%special%~
END

DEFINE_PATCH_FUNCTION ADD_ITEM_ABIL_EFFECT_ACTI
INT_VAR
  position = 9999
  ability  = "-1"
  opcode   = 0    //0x00 SHORT
  target   = 0    //0x02 BYTE   0-9
  power    = 0    //0x03 BYTE
  param1   = 0    //0x04 LONG
  param2   = 0    //0x08 LONG
  timing   = 0    //0x0c BYTE   0-10, 4096
  resist   = 0    //0x0d BYTE
  duration = 0    //0x0e LONG
  prob1    = 100  //0x12 BYTE
  prob2    = 0    //0x13 BYTE
  dicenum  = 0    //0x1c LONG
  dicesize = 0    //0x20 LONG
  saveint  = "-1" //0x24 LONG
  savebon  = 0    //0x28 LONG
  special  = 0    //0x2c LONG
STR_VAR
  resource = ""   //0x14 ASCII
  saves    = ""   //SPELL, BREATH, DEATH, WANDS, POLYMORPH - 0x24 LONG
RET
  position
BEGIN
  READ_SHORT 0x68 abil_num
  PATCH_IF (abil_num > 0) BEGIN
    READ_LONG  0x64 abil_off
    READ_SHORT 0x6e first
    READ_LONG  0x6a eff_off
    PATCH_IF (first > 0) BEGIN no_abil = 1 END ELSE BEGIN SET no_abil = 0 END
    PATCH_IF (ability < 0) OR (ability > 2) BEGIN
      FOR ( i = 0 ; i < abil_num ; ++i ) BEGIN
        READ_SHORT abil_off + 0x38 * i + 0x20 eo
        SET eff_off = eff_off + eo * 0x30
        LPF ADD_ITEM_ABIL_EFFECT_ACTI_EX
          INT_VAR
            position = position
            abils    = abil_num
            abil_nm  = i
            offsetA  = abil_off + 0x38 * i
            eff_off  = eff_off
            no_abil  = no_abil
            opcode   = opcode
            target   = target
            power    = power
            param1   = param1
            param2   = param2
            timing   = timing
            resist   = resist
            duration = duration
            prob1    = prob1
            prob2    = prob2
            dicenum  = dicenum
            dicesize = dicesize
            saveint  = saveint
            savebon  = savebon
            special  = special
          STR_VAR
            resource = EVAL ~%resource%~
            saves    = EVAL ~%saves%~
        END
      END
    END ELSE BEGIN
      PATCH_IF (abil_num > ability) BEGIN
        READ_SHORT abil_off + 0x38 * ability + 0x20 eo
        SET eff_off = eff_off + eo * 0x30
        LPF ADD_ITEM_ABIL_EFFECT_ACTI_EX
          INT_VAR
            position = position
            abils    = abil_num
            abil_nm  = ability
            offsetA  = abil_off + 0x38 * ability
            eff_off  = eff_off
            no_abil  = no_abil
            opcode   = opcode
            target   = target
            power    = power
            param1   = param1
            param2   = param2
            timing   = timing
            resist   = resist
            duration = duration
            prob1    = prob1
            prob2    = prob2
            dicenum  = dicenum
            dicesize = dicesize
            saveint  = saveint
            savebon  = savebon
            special  = special
          STR_VAR
            resource = EVAL ~%resource%~
            saves    = EVAL ~%saves%~
        END
      END
    END
  END ELSE BEGIN
    position = 0 - 1
  END
END
//BLOCKEND
//BLOCKEND


//BLOCK SPELLS

//BLOCKEND






























